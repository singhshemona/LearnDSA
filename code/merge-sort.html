<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Hello World</title>
    <meta name="keywords" content="greeting, hello, world, earth, hola">
    <meta name="description" content="Lorem ipsum dolor sit amet.">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
    <link href="includes/style.css" rel="stylesheet" type="text/css" media="screen">
    <link href="includes/style-print.css" rel="stylesheet" type="text/css" media="print">
    <link rel="icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
</head>

<body>
    <div class="banner">
        <h1><a href="index.html"><span class="learn">Learn</span><span class="blue">DS</span><span class="red">A</span></a></h1>
        <ul>
            <li><a href="/data-structures.html" class="underline">data structures</a></li>
            <li><a href="/algorithms.html" class="underline on">algorithms</a></li>
            <li><a href="/about.html" class="underline">about</a></li>
        </ul>
    </div>

    <div class="algorithm-body">
        <h2 class="algorithm-name">Merge Sort <span class="runtime">O(nlogn)</span></h2>

        <h3 class="algorithm-heading">Description</h3>
        <p>Merge Sort is a sorting algorithm that uses a divide-and-conquer method to sort given data.</p>

        <h3 class="algorithm-heading">Procedure</h3>
        <p>Divide by finding the number (q) of the position midway between a starting point (p) and an ending point (r). Do this by finding a midpoint: add p and r, divide by 2, and round down. Recursively sorting the subarrays in each of the two subproblems created by the divide step. That is, recursively sort the subarray array[p..q] and recursively sort the subarray[q+1..r]. Combine by merging the two sorted subarrays back into the single sorted subarray array[p..r].
        </p>
        <h3 class="algorithm-heading">Runtime Explaination</h3>
        <p>At each pass of mergesort, the the size of the sorted subsections double. First there are 2 subsections, then 4, then 8, etc. This doubling gives us logn time. Each pass of the data will take the time proportional to number of elements there are, so this gives us n time.</p>

        <h3 class="algorithm-heading">Examples</h3>
        <p>Suppose you have a list of 10 places to travel and you have two friends. You ask both the friends to order the list in descending order of their liking. You will now have two arrays after that, and you want to count the number of differences, or inversions they have. This will be done with mergesort. The more inversions, the more dissimilar there choices are, the less inversions, the more similar their choices are.</p>
        <h3 class="algorithm-heading">Sources</h3>
        <a href="https://www.quora.com/What-is-the-real-time-application-of-merge-sorting
">Quora</a>
    </div>

</body>

</html>